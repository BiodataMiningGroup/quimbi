
/*
glmvilib v2.0.0

A small library for processing multivariate image datasets using WebGL.

Author: Martin Zurowietz
 */

(function() {
  "use strict";

  /*
  The function called is not permitted in the current glmvilib status.
   */
  var CapabilityError, GLmvilib, ParameterError, StatusError, WebGLError,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  StatusError = (function(_super) {
    __extends(StatusError, _super);

    function StatusError(message) {
      this.message = message;
      this.name = 'StatusError';
    }

    return StatusError;

  })(Error);


  /*
  There is something wrong with the given parameters.
   */

  ParameterError = (function(_super) {
    __extends(ParameterError, _super);

    function ParameterError(message) {
      this.message = message;
      this.name = 'ParameterError';
    }

    return ParameterError;

  })(Error);


  /*
  There is something wrong with the shader or shader program.
   */

  WebGLError = (function(_super) {
    __extends(WebGLError, _super);

    function WebGLError(message) {
      this.message = message;
      this.name = 'WebGLError';
    }

    return WebGLError;

  })(Error);


  /*
  The system capabilities are not sufficient for processing the given dataset.
   */

  CapabilityError = (function(_super) {
    __extends(CapabilityError, _super);

    function CapabilityError(message) {
      this.message = message;
      this.name = 'CapabilityError';
    }

    return CapabilityError;

  })(Error);


  /*
  glmvilib constructor function.
   */

  GLmvilib = function() {

    /*
    	CONSTANTS ===================================================================
     */

    /*
    	Stores the status constants.
     */
    var STATUS, TEXTURE_ID, addTexture, animationFrameID, assembleTexture3DFunction, assets, bindInternalTextures, compileShader, createFragmentShader, createShaderProgram, createVertexShader, fetchShader, fillTexture, gl, helpers, params, precompileFragmentShader, precompileVertexShader, prepareGL, programs, readParams, render, setUpWebGL, status, textureInfo, useInternalTexturePositions, useInternalTextures, useInternalVertexPositions;
    STATUS = {

      /*
      		Nothing is set up yet.
       */
      NONE: 0x0,

      /*
      		WebGL is initialized and the input parameters are read. Now custom shaders
      		can be loaded.
       */
      INIT: 0x1,

      /*
      		The texture image units with the tile-images are all loaded and glmvilib
      		is ready to render. Now custom shaders can't be added any more.
       */
      REDY: 0x2
    };

    /*
    	Make constants constant.
     */
    Object.freeze(STATUS);

    /*
    	ID prefix for the internal textures.
     */
    TEXTURE_ID = 'glmvilib_texture_';

    /*
    	VARIABLES ===================================================================
     */

    /*
    	WebGL context.
     */
    gl = null;

    /*
    	Indicates if the WebGL context and the params object are properly initialized
    	and the dataset can be processed.
     */
    status = STATUS.NONE;

    /*
    	ID of the animation frame for the rendering loop.
     */
    animationFrameID = null;

    /*
    	Information about the dataset.
     */
    params = {

      /*
      		Height of the image.
       */
      height: 0,

      /*
      		Width of the image.
       */
      width: 0,

      /*
      		Dimension of the dataset (number of channels).
       */
      channels: 0,

      /*
      		Number of tiles this dataset needs (4 channels merged to one rgba image).
       */
      tiles: 0,

      /*
      		Number of channels used in the very last tile of the dataset since the
      		number of channels doesn't have to be a multiple of 4.
       */
      dimLastTile: 0,

      /*
      		Number of rows of tiles per texture image unit.
       */
      rows: 0,

      /*
      		Number of tiles in each of these rows.
       */
      columns: 0
    };

    /*
    	Prevent new properties from being added.
     */
    Object.seal(params);

    /*
    	Information about the texture properties on this system.
     */
    textureInfo = {

      /*
      		Number of available texture image units.
       */
      availableUnits: 0,

      /*
      		Number of texture image units that must not be used by glmvilib.
       */
      reservedUnits: 0,

      /*
      		Maximal available texture size in pixels.
       */
      availableSize: 0,

      /*
      		Number of textures needed for the dataset.
       */
      internalTextures: 0
    };

    /*
    	Prevent new properties from being added.
     */
    Object.seal(textureInfo);

    /*
    	Stores all registered shader programs.
     */
    programs = {};

    /*
    		This is an example shader program object.
    		 *exampleID:

    			WebGL pointer for useProgram etc.
    		 *	self: null

    			Callback for updating shader variables. Gets called before each
    			rendering with this program.
    		 *	callback: null
     */

    /*
    	Object to store pointers that has to be shared between shaders. For example
    	the texture coordinate or vertex position buffers. The constructor functions
    	of the shaders get this object as parameter and can add new pointers.
     */
    assets = {

      /*
      		All kinds of WebGL buffer objects such as ARRAY_BUFFER.
       */
      buffers: {},

      /*
      		All existing framebuffer objects.
       */
      framebuffers: {},

      /*
      		All existing texture objects.
       */
      textures: {}
    };

    /*
    	Object of helper functions for external shader program creation.
     */
    helpers = {};

    /*
    	PRIVATE FUNCTIONS ===========================================================
     */

    /*
    	Creates a new WebGL context in the given canvas and reads out the available
    	texture capabilities.
     */
    setUpWebGL = function(canvas, attributes) {
      var context;
      if (!window.WebGLRenderingContext) {
        throw new CapabilityError("Your browser doesn't support WebGL!");
      }
      context = canvas.getContext('webgl', attributes);
      if (!context) {
        throw new CapabilityError("Your browser doesn't support WebGL!");
      }
      Object.defineProperties(textureInfo, {
        availableUnits: {
          value: context.getParameter(context.MAX_TEXTURE_IMAGE_UNITS),
          writable: false
        },
        availableSize: {
          value: context.getParameter(context.MAX_TEXTURE_SIZE),
          writable: false
        }
      });
      return context;
    };

    /*
    	Fills the params object with the input data and computes needed number of
    	texture image units.
     */
    readParams = function(input) {
      var availableUnits, neededTextures, tilesPerTexture;
      if (typeof input.height === 'number') {
        params.height = input.height;
      } else {
        throw new ParameterError("Dataset input has no 'height' attribute.");
      }
      if (typeof input.width === 'number') {
        params.width = input.width;
      } else {
        throw new ParameterError("Dataset input has no 'width' attribute.");
      }
      if (typeof input.channels === 'number') {
        params.channels = input.channels;
      } else {
        throw new ParameterError("Dataset input has no 'channels' attribute.");
      }
      if (typeof input.reservedUnits === 'number') {
        Object.defineProperty(textureInfo, 'reservedUnits', {
          value: input.reservedUnits,
          writable: false
        });
      }
      params.tiles = Math.ceil(params.channels / 4);
      params.dimLastTile = params.channels % 4;
      availableUnits = textureInfo.availableUnits - textureInfo.reservedUnits;
      tilesPerTexture = Math.ceil(params.tiles / availableUnits);
      params.rows = 1;
      params.columns = 1;
      while (params.rows * params.columns < tilesPerTexture) {
        if (params.rows * params.height > params.columns * params.width) {
          params.columns++;
        } else {
          params.rows++;
        }
      }
      Object.freeze(params);
      if (params.columns * params.width > textureInfo.availableSize || params.rows * params.height > textureInfo.availableSize) {
        throw new CapabilityError("Not enough memory available for this dataset. Needed texture dimension " + (params.columns * params.width) + " x " + (params.rows * params.height) + " but only " + textureInfo.availableSize + " x " + textureInfo.availableSize + " available.");
      }
      neededTextures = params.tiles < availableUnits ? params.tiles : availableUnits;
      Object.defineProperty(textureInfo, 'internalTextures', {
        value: neededTextures,
        writable: false
      });
      return params;
    };

    /*
    	Creates the basic assets such as texture coordinate or vertex coordinate
    	buffers.
     */
    prepareGL = function() {
      var textureCoordinates, vertexCoordinates;
      Object.defineProperty(assets.buffers, 'textureCoordinateBuffer', {
        value: gl.createBuffer(),
        writable: false,
        enumerable: true
      });
      textureCoordinates = new Float32Array([0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1]);
      gl.bindBuffer(gl.ARRAY_BUFFER, assets.buffers.textureCoordinateBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, textureCoordinates, gl.STATIC_DRAW);
      Object.defineProperty(assets.buffers, 'vertexCoordinateBuffer', {
        value: gl.createBuffer(),
        writable: false,
        enumerable: true
      });
      vertexCoordinates = new Float32Array([-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1]);
      gl.bindBuffer(gl.ARRAY_BUFFER, assets.buffers.vertexCoordinateBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, vertexCoordinates, gl.STATIC_DRAW);
    };

    /*
    	Loads the shader as String from the given uri.
     */
    fetchShader = function(uri) {
      var xhr, _ref;
      if (!uri) {
        throw new ParameterError("Bad URI '" + uri + "'.");
      }
      xhr = new XMLHttpRequest();
      xhr.overrideMimeType('text/plain');
      xhr.open('get', uri, false);
      xhr.send();
      if (!((200 <= (_ref = xhr.status) && _ref < 300) || xhr.status === 0)) {
        throw new ParameterError("" + xhr.statusText);
      }
      return xhr.responseText;
    };

    /*
    	Precompiles the vertex shader string, thus resolving glmvilib-specific
    	regular expressions within the code.
     */
    precompileVertexShader = function(vertexShader) {
      return vertexShader;
    };

    /*
    	Assembles the glmvilib_texture3D function along with the needed samplers for
    	this dataset as string to be included in the fragment shaders.
     */
    assembleTexture3DFunction = function() {
      var columns, reserved, ret, sampler, tileHeight, tileWidth, tilesPerTexture;
      ret = "\n";
      sampler = textureInfo.internalTextures;
      reserved = textureInfo.reservedUnits;
      columns = params.columns;
      tilesPerTexture = "" + (params.rows * columns) + ".0";
      tileWidth = 1 / columns;
      tileHeight = 1 / params.rows;
      if (columns % 1 === 0) {
        columns = "" + columns + ".0";
      }
      if (tileWidth % 1 === 0) {
        tileWidth = "" + tileWidth + ".0";
      }
      if (tileHeight % 1 === 0) {
        tileHeight = "" + tileHeight + ".0";
      }
      while (--sampler >= 0) {
        ret += "uniform sampler2D " + TEXTURE_ID + (sampler + reserved) + ";\n";
      }
      ret += "vec4 glmvilib_texture3D(vec2 position, float position_z) {\n	float index_on_sampler = mod(position_z, " + tilesPerTexture + ");\n	float column = mod(index_on_sampler, " + columns + ");\n	float row = floor(index_on_sampler / " + columns + ");\n\n	vec2 coords_2d = vec2(\n		" + tileWidth + " * (column + position.x),\n		" + tileHeight + " * (row + position.y)\n	);\n\n	float sampler_index = floor(position_z / " + tilesPerTexture + ");";
      sampler = textureInfo.internalTextures;
      while (--sampler >= 0) {
        ret += "\n\tif (sampler_index == " + sampler + ".0) return texture2D(" + TEXTURE_ID + (sampler + reserved) + ", coords_2d);";
      }
      ret += "\n	return vec4(0);\n}\n";
      return ret;
    };

    /*
    	Precompiles the fragment shader string, thus resolving glmvilib-specific
    	regular expressions within the code.
     */
    precompileFragmentShader = function(fragmentShader) {
      fragmentShader = fragmentShader.replace(/<%=TILES=%>/g, params.tiles);
      fragmentShader = fragmentShader.replace(/<%=CHANNELS_LAST_TILE=%>/g, params.dimLastTile);
      fragmentShader = fragmentShader.replace(/<%=TEXTURE_3D=%>/, assembleTexture3DFunction());
      return fragmentShader;
    };

    /*
    	Compiles the source of an already created shader and returns the compiled
    	shader if no errors occurred.
     */
    compileShader = function(shader, source) {
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        throw new WebGLError("" + (gl.getShaderInfoLog(shader)));
      }
      return shader;
    };

    /*
    	Creates and returns a new vertex shader from the given source.
     */
    createVertexShader = function(source) {
      return compileShader(gl.createShader(gl.VERTEX_SHADER), source);
    };

    /*
    	Creates and returns a new fragment shader from the given source.
     */
    createFragmentShader = function(source) {
      return compileShader(gl.createShader(gl.FRAGMENT_SHADER), source);
    };

    /*
    	Creates a new shader program, attaches the given vertex and fragment shaders,
    	links the program and returns it.
     */
    createShaderProgram = function(vertexShader, fragmentShader) {
      var program;
      program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        throw new WebGLError("" + (gl.getProgramInfoLog(program)));
      }
      return program;
    };

    /*
    	Adds a new texture and occupies a texture image unit with it. Adds the texture
    	information to the assets object and returns assets texture object.
     */
    addTexture = function(id) {
      var texture;
      if (!(id && typeof id === 'string')) {
        throw new ParameterError("Expected String as texture ID but got " + id + ".");
      }
      texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
      return assets.textures[id] = texture;
    };
    helpers.newTexture = addTexture;

    /*
    	Loads the given tile images to an existing texture.
     */
    fillTexture = function(texture, images) {
      var image, index, _i, _len;
      if (!(images instanceof Array)) {
        throw new ParameterError('Expected image array to fill texture.');
      }
      if (images.length > params.rows * params.columns) {
        throw new ParameterError("Expected " + (params.rows * params.columns) + " image(s) to fill the texture but got " + images.length + ".");
      }
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, params.columns * params.width, params.rows * params.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      for (index = _i = 0, _len = images.length; _i < _len; index = ++_i) {
        image = images[index];
        gl.texSubImage2D(gl.TEXTURE_2D, 0, (index % params.columns) * params.width, Math.floor(index / params.columns) * params.height, gl.RGBA, gl.UNSIGNED_BYTE, image);
      }
    };

    /*
    	Locates the internal textures to their samplers in a shader program that uses
    	TEXTURE_3D.
     */
    useInternalTextures = function(program) {
      var number, reserved, texture;
      if (!(program instanceof WebGLProgram)) {
        throw new ParameterError("glmvilib.useInternalTextures: Expected WebGLProgram but got " + program + ".");
      }
      number = textureInfo.internalTextures;
      reserved = textureInfo.reservedUnits;
      while (number--) {
        texture = gl.getUniformLocation(program, TEXTURE_ID + (number + reserved));
        gl.uniform1i(texture, number + reserved);
      }
    };
    helpers.useInternalTextures = useInternalTextures;

    /*
    	Binds the vertex coordinate buffer to a_vertex_position in the given shader
    	program.
     */
    useInternalVertexPositions = function(program) {
      var vertexCoordinates;
      if (!(program instanceof WebGLProgram)) {
        throw new ParameterError("glmvilib.useInternalVertexPositions: Expected WebGLProgram but got " + program + ".");
      }
      vertexCoordinates = gl.getAttribLocation(program, 'a_vertex_position');
      gl.enableVertexAttribArray(vertexCoordinates);
      gl.bindBuffer(gl.ARRAY_BUFFER, assets.buffers.vertexCoordinateBuffer);
      gl.vertexAttribPointer(vertexCoordinates, 2, gl.FLOAT, false, 0, 0);
    };
    helpers.useInternalVertexPositions = useInternalVertexPositions;

    /*
    	Binds the texture coordinate buffer to a_texture_position in the given shader
    	program.
     */
    useInternalTexturePositions = function(program) {
      var textureCoordinates;
      if (!(program instanceof WebGLProgram)) {
        throw new ParameterError("glmvilib.useInternalTexturePositions: Expected WebGLProgram but got " + program + ".");
      }
      textureCoordinates = gl.getAttribLocation(program, 'a_texture_position');
      gl.enableVertexAttribArray(textureCoordinates);
      gl.bindBuffer(gl.ARRAY_BUFFER, assets.buffers.textureCoordinateBuffer);
      gl.vertexAttribPointer(textureCoordinates, 2, gl.FLOAT, false, 0, 0);
    };
    helpers.useInternalTexturePositions = useInternalTexturePositions;

    /*
    	Binds the internal textures for a shader program that uses TEXTURE_3D.
     */
    bindInternalTextures = function() {
      var number, reserved;
      number = textureInfo.internalTextures;
      reserved = textureInfo.reservedUnits;
      while (number--) {
        gl.activeTexture(gl.TEXTURE0 + number + reserved);
        gl.bindTexture(gl.TEXTURE_2D, assets.textures[TEXTURE_ID + (number + reserved)]);
      }
    };
    helpers.bindInternalTextures = bindInternalTextures;
    Object.freeze(helpers);

    /*
    	Renders the scene once with all shaders whose ID is given as a parameter of
    	this function in the given order.
     */
    render = function() {
      var id, program, _i, _len;
      for (_i = 0, _len = arguments.length; _i < _len; _i++) {
        id = arguments[_i];
        program = programs[id];
        gl.useProgram(program.self);
        program.callback(gl, program.self, assets, helpers);
        gl.drawArrays(gl.TRIANGLES, 0, 6);
      }
    };

    /*
    	TESTING =====================================================================
     */

    /*
    	Expose private variables and functions for testing. Strip this block for
    	production build.
     */
    this._gl = function() {
      return gl;
    };
    this._status = function() {
      return status;
    };
    this._animationFrameID = function() {
      return animationFrameID;
    };
    this._params = params;
    this._textureInfo = textureInfo;
    this._programs = programs;
    this._assets = assets;
    this._helpers = helpers;
    this._setUpWebGL = setUpWebGL;
    this._readParams = readParams;
    this._prepareGL = prepareGL;
    this._fetchShader = fetchShader;
    this._precompileVertexShader = precompileVertexShader;
    this._assembleTexture3DFunction = assembleTexture3DFunction;
    this._precompileFragmentShader = precompileFragmentShader;
    this._compileShader = compileShader;
    this._createVertexShader = createVertexShader;
    this._createFragmentShader = createFragmentShader;
    this._createShaderProgram = createShaderProgram;
    this._addTexture = addTexture;
    this._fillTexture = fillTexture;
    this._useInternalTextures = useInternalTextures;
    this._useInternalVertexPositions = useInternalVertexPositions;
    this._useInternalTexturePositions = useInternalTexturePositions;
    this._bindInternalTextures = bindInternalTextures;
    this._render = render;

    /*
    	PUBLIC FUNCTIONS ============================================================
     */

    /*
    	STATUS.NONE
     */

    /*
    	Initializes WebGL on the given canvas element and calls readParams with the
    	given input data and then prepareGL.
     */
    this.init = (function(_this) {
      return function(canvas, input) {
        var e;
        if (status !== STATUS.NONE) {
          throw new StatusError("glmvilib.init: glmvilib is already initialized. Call finish() first.");
        }
        try {
          gl = setUpWebGL(canvas, {
            preserveDrawingBuffer: true,
            premultipliedAlpha: false
          });
          readParams(input);
          prepareGL();
          status = STATUS.INIT;
        } catch (_error) {
          e = _error;
          _this.finish();
          throw e;
        }
      };
    })(this);

    /*
    	STATUS.INIT
     */

    /*
    	Loads the raw code of vertex and fragment shaders, precompiles it (resolves
    	glmvilib-specific regular expressions within the code), creates the
    	shader program, adds it to the programs object and calls the constructor
    	function.
     */
    this.addProgram = function(program) {
      var e, fragmentShader, fragmentShaderString, programPointer, vertexShader, vertexShaderString;
      if (status === STATUS.NONE) {
        throw new StatusError("glmvilib.addProgram: glmvilib is not yet initialized.");
      }
      if (typeof program.id !== 'string') {
        throw new ParameterError('glmvilib.addProgram: Program ID must be a String.');
      }
      if (!(program.constructor instanceof Function)) {
        throw new ParameterError('glmvilib.addProgram: Program constructor must be a function.');
      }
      if (program.callback && !program.callback instanceof Function) {
        throw new ParameterError('glmvilib.addProgram: Program callback must be a function.');
      }
      try {
        vertexShaderString = fetchShader(program.vertexShaderUrl);
      } catch (_error) {
        e = _error;
        throw new ParameterError("glmvilib.addProgram: Vertex shader '" + program.vertexShaderUrl + "' cannot be loaded. " + e.message);
      }
      vertexShaderString = precompileVertexShader(vertexShaderString);
      try {
        vertexShader = createVertexShader(vertexShaderString);
      } catch (_error) {
        e = _error;
        throw new WebGLError("glmvilib.addProgram: An error occurred compiling the vertex shader.\n" + e.message);
      }
      try {
        fragmentShaderString = fetchShader(program.fragmentShaderUrl);
      } catch (_error) {
        e = _error;
        throw new ParameterError("glmvilib.addProgram: Fragment shader '" + program.fragmentShaderUrl + "' cannot be loaded.\n" + e.message);
      }
      fragmentShaderString = precompileFragmentShader(fragmentShaderString);
      try {
        fragmentShader = createFragmentShader(fragmentShaderString);
      } catch (_error) {
        e = _error;
        throw new WebGLError("glmvilib.addProgram: An error occurred compiling the fragment shader.\n" + e.message);
      }
      try {
        programPointer = createShaderProgram(vertexShader, fragmentShader);
      } catch (_error) {
        e = _error;
        throw new WebGLError("glmvilib.addProgram: An error occurred creating the shader program '" + program.id + "'.\n" + e.message);
      }
      try {
        gl.useProgram(programPointer);
        program.constructor(gl, programPointer, assets, helpers);
        gl.useProgram(null);
      } catch (_error) {
        e = _error;
        throw new WebGLError("glmvilib.addProgram: The constructor of '" + program.id + "' caused an error.\n" + e.message);
      }
      programs[program.id] = {
        self: programPointer,
        callback: program.callback ? program.callback : function() {}
      };
      return program.id;
    };

    /*
    	Stores the tile-images to the remaining texture image units. When finished,
    	glmvilib is ready to render.
     */
    this.storeTiles = function(images) {
      var firstTile, image, lastTile, reserved, texture, tilesPerTexture, toFill, _i, _len;
      switch (status) {
        case STATUS.NONE:
          throw new StatusError("glmvilib.storeTiles: glmvilib is not yet initialized.");
          break;
        case STATUS.INIT:
          break;
        default:
          throw new StatusError("glmvilib.storeTiles: glmvilib is already ready to render.");
      }
      if (!(images instanceof Array)) {
        throw new ParameterError('glmvilib.storeTiles: Expected an array as input.');
      }
      if (images.length !== params.tiles) {
        throw new ParameterError("glmvilib.storeTiles: Expected array length " + params.tiles + " but got " + images.length + ".");
      }
      for (_i = 0, _len = images.length; _i < _len; _i++) {
        image = images[_i];
        if (!(image instanceof HTMLImageElement)) {
          throw new ParameterError("glmvilib.storeTiles: Expected an array of images but got " + image + ".");
        }
      }
      toFill = textureInfo.internalTextures;
      reserved = textureInfo.reservedUnits;
      tilesPerTexture = params.rows * params.columns;
      while (toFill--) {
        texture = addTexture(TEXTURE_ID + (toFill + reserved));
        firstTile = toFill * tilesPerTexture;
        lastTile = firstTile + tilesPerTexture;
        fillTexture(texture, images.slice(firstTile, lastTile));
      }
      status = STATUS.REDY;
    };

    /*
    	STATUS.REDY
     */

    /*
    	Calls the render() function once after checking the given arguments.
     */
    this.render = (function(_this) {
      return function() {
        var id, _i, _len;
        switch (status) {
          case STATUS.NONE:
            throw new StatusError("glmvilib is not yet initialized.");
            break;
          case STATUS.INIT:
            throw new StatusError("glmvilib is not yet ready to render.");
            break;
          case STATUS.REDY:
            break;
          default:
            throw new StatusError("glmvilib is in undefined status.");
        }
        for (_i = 0, _len = arguments.length; _i < _len; _i++) {
          id = arguments[_i];
          if (!programs[id]) {
            throw new CapabilityError("Program '" + id + "' does not exist.");
          }
        }
        render.apply(_this, arguments);
      };
    })(this);

    /*
    	Calls the render() function in a loop until the stop() function of the
    	returned object is called.
     */
    this.renderLoop = (function(_this) {
      return function() {
        var id, rendering, _arguments, _i, _len;
        switch (status) {
          case STATUS.NONE:
            throw new StatusError("glmvilib is not yet initialized.");
            break;
          case STATUS.INIT:
            throw new StatusError("glmvilib is not yet ready to render.");
            break;
          case STATUS.REDY:
            break;
          default:
            throw new StatusError("glmvilib is in undefined status.");
        }
        for (_i = 0, _len = arguments.length; _i < _len; _i++) {
          id = arguments[_i];
          if (!programs[id]) {
            throw new CapabilityError("Program '" + id + "' does not exist.");
          }
        }
        _arguments = arguments;
        window.cancelAnimationFrame(animationFrameID);
        rendering = function() {
          animationFrameID = window.requestAnimationFrame(rendering);
          return render.apply(_this, _arguments);
        };
        rendering();
        return {
          stop: function() {
            return window.cancelAnimationFrame(animationFrameID);
          }
        };
      };
    })(this);

    /*
    	Provides the readPixels function without direct access to the gl object.
     */
    this.getPixels = function(xOffset, yOffset, width, height, pixels) {
      var pixelNumber;
      switch (status) {
        case STATUS.NONE:
          throw new StatusError("glmvilib is not yet initialized.");
          break;
        case STATUS.INIT:
          throw new StatusError("glmvilib is not yet ready to render.");
          break;
        case STATUS.REDY:
          break;
        default:
          throw new StatusError("glmvilib is in undefined status.");
      }
      if (typeof xOffset !== 'number') {
        throw new ParameterError("glmvilib.getPixels: xOffset must be a number.");
      }
      if (typeof yOffset !== 'number') {
        throw new ParameterError("glmvilib.getPixels: yOffset must be a number.");
      }
      if (typeof width !== 'number') {
        throw new ParameterError("glmvilib.getPixels: width must be a number.");
      }
      if (typeof height !== 'number') {
        throw new ParameterError("glmvilib.getPixels: height must be a number.");
      }
      if (!(pixels instanceof Uint8Array)) {
        throw new ParameterError("glmvilib.getPixels: Pixel array must be Uint8Array.");
      }
      pixelNumber = width * height * 4;
      if (pixelNumber !== pixels.length) {
        throw new ParameterError("glmvilib.getPixels: Length of pixel array must be " + pixelNumber + " but is " + pixels.length + ".");
      }
      gl.readPixels(xOffset, yOffset, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
    };

    /*
    	Provides the viewport function without direct access to the gl object.
     */
    this.setViewport = function(xOffset, yOffset, width, height) {
      switch (status) {
        case STATUS.NONE:
          throw new StatusError("glmvilib is not yet initialized.");
          break;
        case STATUS.INIT:
          throw new StatusError("glmvilib is not yet ready to render.");
          break;
        case STATUS.REDY:
          break;
        default:
          throw new StatusError("glmvilib is in undefined status.");
      }
      if (typeof xOffset !== 'number') {
        throw new ParameterError("glmvilib.getPixels: xOffset must be a number.");
      }
      if (typeof yOffset !== 'number') {
        throw new ParameterError("glmvilib.getPixels: yOffset must be a number.");
      }
      if (typeof width !== 'number') {
        throw new ParameterError("glmvilib.getPixels: width must be a number.");
      }
      if (typeof height !== 'number') {
        throw new ParameterError("glmvilib.getPixels: height must be a number.");
      }
      gl.viewport(xOffset, yOffset, width, height);
    };

    /*
    	Stops rendering, calls all destructors of existing shader programs and
    	deletes all of glmvilib's own buffers and textures and shaders.
     */
    this.finish = function() {
      var buffer, framebuffer, id, name, program, shader, shaders, texture, _i, _len, _ref, _ref1, _ref2;
      window.cancelAnimationFrame(animationFrameID);
      if (gl) {
        _ref = assets.buffers;
        for (name in _ref) {
          buffer = _ref[name];
          if (buffer) {
            gl.deleteBuffer(buffer);
          }
        }
        _ref1 = assets.framebuffers;
        for (name in _ref1) {
          framebuffer = _ref1[name];
          if (framebuffer) {
            gl.deleteBuffer(framebuffer);
          }
        }
        _ref2 = assets.textures;
        for (id in _ref2) {
          texture = _ref2[id];
          if (texture) {
            gl.deleteTexture(texture.self);
          }
        }
        for (id in programs) {
          program = programs[id];
          if (!(program)) {
            continue;
          }
          shaders = gl.getAttachedShaders(program.self);
          for (_i = 0, _len = shaders.length; _i < _len; _i++) {
            shader = shaders[_i];
            gl.deleteShader(shader);
          }
          gl.deleteProgram(program.self);
        }
      }
      window.glmvilib = new GLmvilib();
      Object.freeze(window.glmvilib);
    };
  };


  /*
  Create global glmvilib object.
   */

  window.glmvilib = new GLmvilib();


  /*
  Make glmvilib object immutable.
   */

  Object.freeze(window.glmvilib);


  /*
  Hook up the finish function for closing of the website.
   */

  window.addEventListener('beforeunload', glmvilib.finish);

}).call(this);
